[{
  "_id": {
    "$oid": "649ee2850f9bd4176dfe55e2"
  },
  "title": "Git",
  "description": "# **GOOD GIT PRACTICES**  \n\n- Some goods git practices includes:\n\n1. Make frequent and atomic commits, that is, with related and significant changes. \n2. Keep an history of clear and readable confirmations.\n3. Use branches to work on new characteristics or issues corrections.\n4. Carry out tests before branch merging.\n5. Use clear and descriptive confirmattion messages.\n6. Keep updated the local repository with remote repository changes.\n7. Use .gitignore files to avoid tracking innecesarry files.\n8. Colaborate and communicate with other developers using VCS tools adecually.\n\n# **What´s VCS?**  \n\n- VCS means (Version Control System) and is a software that let make the management and the control of source code along the time. It's helpful because it allows to keep a register of the different versions and reviews of the source code, facilitating the colaboration between developers and bringin them the posibility to make changes if it´s necessary.\n\n# **GOOD PRACTICES ON GIT BRANCHING**  \n\n1. Create a branch for each new function or issues solving.\n2. Name the branches as descriptive and significantly.\n3. Keep actualized branches with lastes changes on main branch.\n4. Make exahustives tests on branches before fusionate with the main branch.\n\n# **What means merge/merging?**  \n\n- Merge is a term used on git to merge the changes between a branch with another one branch. When a merge is realized, the realized changes on a branch will be incorporated to the another one branch, what lets consolidate the realiced advances in differents branches on unic development line.\n\n# **What´s .gitignore?**  \n\n- .gitignore is a file used on git to specify what files or directoris have to been ignored by the VCS. Additioning rules in this file, will indicate to git that doesn't make any tracking and  including on the repository the files or directories especified. This is useful to exclude some generated files automatically, config local files or any file that doesn´t means any importance to the project.\n\n# **Markdown** \n\n- Makrdown is a marked language used to text format and structure in a easy way. Is tipically used on the project documentation and plataforms as github to write READMEs, documentation technic and blogs. Markdown allows add titles, links, lists, images and others basic text format elements without the needs of use complex HTML labels.",
  "creationDate": {
    "$date": "2023-06-30T05:00:00.000Z"
  },
  "__v": 0
},
{
  "_id": {
    "$oid": "649eef8a0f9bd4176dfe55f3"
  },
  "title": "Javascript",
  "description": "# **JAVASCRIPT CONSIDERATIONS**\n\n# **ES6 Standards**\n\n## **ES6 (ECMAScript 2015)** \n\n- introduced significant updates to JavaScript, bringing numerous new features and syntax improvements. Some notable additions include arrow functions, block-scoped variables (let and const), classes, modules, template literals, destructuring assignments, and more. These enhancements enhanced JavaScript's readability, modularity, and overall programming capabilities.\n\n# **ES2020 Highlights (what's coming?)**  \n\n- ES2020, also known as ECMAScript 2020, introduced several new features to JavaScript. Notable highlights include the Nullish Coalescing Operator (??), Optional Chaining (?.), BigInt data type, globalThis, dynamic import(), and more. These additions aimed to enhance JavaScript's expressiveness, developer productivity, and overall language capabilities.\n\n# **CONST vs LET**\n\n- \"const\" and \"let\" are block-scoped variable declarations introduced in ES6. \"const\" declares a constant variable that cannot be reassigned after initialization, whereas \"let\" declares a mutable variable that can be reassigned within its block scope. In general, it is recommended to use \"const\" for values that won't change and \"let\" for values that will change.\n\n# **OBJECTS**\n\n- Objects in JavaScript are data structures that allow you to store key-value pairs. They are represented by curly braces ({}) and support dynamic addition and removal of properties. Objects can also contain functions, which are called methods when they belong to an object. Objects are a fundamental part of JavaScript and provide a powerful way to organize and manipulate data.\n\n# **OBJECT REFERENCE VS VALUES**\n\n- In JavaScript, objects are reference types, while primitive values (like strings or numbers) are value types. When assigning an object to a variable or passing it as a function argument, the reference to the object is copied, not the actual object itself. This means that changes made to the object through one variable will be reflected in other variables referencing the same object. On the other hand, primitive values are copied by value, meaning each variable has its own independent copy of the value.\n\n# **ARRAY AND OBJECT DESESTRUCTURING**\n\n- Array and object destructuring are ES6 features that allow you to extract values from arrays or objects and assign them to variables in a concise and convenient way. Array destructuring uses square brackets ([]), while object destructuring uses curly braces ({}). This feature simplifies variable assignment and can be particularly useful when working with complex data structures.\n\n# **NULL VS UNDEFINED**\n\n- In JavaScript, \"null\" and \"undefined\" are both special values representing the absence of a meaningful value. \"undefined\" is automatically assigned to variables that have been declared but not initialized or assigned a value. \"null\" is a value that can be explicitly assigned to a variable to indicate the absence of a value. They are often used in different contexts, but both imply the absence of a meaningful value.\n\n# **FUNCTIONS AND DIFFERENT WAYS TO DECLARE THEM**\n\n- In JavaScript, functions can be declared using different syntaxes. The most common ways to declare functions are\n\n**Function Declaration:** Using the \"function\" keyword followed by a function name.\n\n**Function Expression:** Assigning a function to a variable using the \"function\" keyword or as an arrow function.\n\n**Arrow Function:** Introduced in ES6, it provides a concise syntax for writing functions, especially for anonymous functions or functions that don't need their own \"this\" context.\n**scope:** Scope refers to the accessibility and visibility of variables, functions, and objects in a particular part of the code. JavaScript has function scope, which means variables defined within a function are only accessible within that function. In ES6, the \"let\" and \"const\" keywords introduced block scope, allowing variables defined within a block (e.g., if statement or for loop) to be accessible only within that block.\n\n# **CLOSURE**\n\n- A closure is a feature in JavaScript that allows a function to retain access to variables from its outer (enclosing) scope even after the outer function has finished executing. It forms a sort of \"closure\" around the variables, enabling the inner function to access and manipulate them. Closures are commonly used for encapsulation, data privacy, and creating functions with persistent state.\n\n# **MAP / FILTER / REDUCE**\n\n**\"map,\" \"filter,\" and \"reduce\"** are higher-order functions available in JavaScript for working with arrays.\n\n**\"map\"** transforms each element of an array into a new array based on a provided callback function.\n**\"filter\"** creates a new array containing only the elements that pass a given condition defined by a callback function.\n**\"reduce\"** reduces an array to a single value by applying a callback function that accumulates the values from left to right.\n\n# **FETCH**\n\n- \"fetch\" is a built-in JavaScript function used to make network requests, particularly for retrieving resources from a server. It provides a modern, Promise-based API for performing HTTP requests and handling responses asynchronously. It simplifies working with APIs and enables fetching data from remote servers without the need for additional libraries like XMLHttpRequest.\n\n# **PROMISES**\n\n- Promises are a feature introduced in ES6 to handle asynchronous operations in JavaScript. A Promise represents the eventual completion or failure of an asynchronous operation, typically a network request or a time-consuming task. It provides a cleaner and more structured way to handle asynchronous code compared to traditional callbacks. Promises can be chained and allow the use of \"then\" and \"catch\" to handle success and error conditions, respectively.\n\n# **ASYNC / AWAIT**\n\n- \"async\" and \"await\" are keywords introduced in ES2017 to simplify asynchronous programming further. The \"async\" keyword is used to declare a function as asynchronous, enabling the use of \"await\" inside that function. \"await\" can be used to pause the execution of an async function until a Promise is resolved or rejected, making asynchronous code appear more synchronous and easier to read.\n\n# **WHAT'S A LINTER?**\n\n- A linter is a tool that analyzes source code to identify potential errors, coding style violations, and other issues. It enforces consistent coding practices and helps maintain code quality and readability. Linters provide warnings and error messages for problematic code patterns, encouraging developers to adhere to best practices and conventions. Linters are widely used in JavaScript development to catch common mistakes and ensure code consistency.\n\n# **ESLINT**\n\n- ESLint is a popular JavaScript linter that helps enforce coding standards and identify potential issues in JavaScript code. It provides a highly configurable set of rules that can be customized to match specific coding styles or project requirements. ESLint integrates seamlessly with most modern code editors and build systems, allowing developers to receive real-time feedback and automatically fix certain issues.",
  "creationDate": {
    "$date": "2023-06-30T05:00:00.000Z"
  },
  "__v": 0
},
{
  "_id": {
    "$oid": "649ef0a70f9bd4176dfe55ff"
  },
  "title": "MongoDB",
  "description": "# **What's MongoDB?**\n\n- MongoDB is a popular NoSQL database management system that provides a flexible and scalable approach to storing and retrieving data. Unlike traditional relational databases, MongoDB uses a document-oriented model, which means data is stored in flexible, JSON-like documents instead of tables with fixed schemas. MongoDB is known for its high performance, horizontal scalability, and ability to handle large amounts of unstructured or semi-structured data.\n\n# **Collections and Documents**\n\n- In MongoDB, data is organized into collections, which are analogous to tables in relational databases. A collection is a group of documents that can contain different fields and structures. A document is a basic unit of data in MongoDB and represents a record or an entity. Documents are stored in collections and can vary in structure and fields, allowing for more flexible and dynamic data models.\n\n# **Schemas**\n\n- While MongoDB is schema-less by default, it supports the use of schemas through the use of validation rules. A schema defines the structure, data types, and constraints for a collection, providing a way to enforce data consistency and integrity. Schemas can be defined using MongoDB's validation rules, such as field types, required fields, uniqueness constraints, and more. Schemas offer the advantage of providing a clear structure to the data while still allowing flexibility.\n\n# **CRUD Operations**\n\n- CRUD stands for Create, Read, Update, and Delete, which are the basic operations for interacting with data in a database. MongoDB supports all these operations natively. With MongoDB, you can easily create new documents, read existing documents, update or modify documents, and delete documents from a collection. These operations are performed using MongoDB's query language and APIs, providing a straightforward way to manipulate data within a MongoDB database.\n\n# **Aggregations**\n\n- Aggregations in MongoDB allow you to perform complex data analysis and transformations on your data. Aggregation pipelines provide a powerful framework for processing and transforming data using multiple stages and operators. With aggregations, you can perform operations such as grouping, filtering, sorting, joining, and computing aggregations like sum, average, count, and more. Aggregations are particularly useful for generating reports, performing data analytics, and deriving insights from your MongoDB data.\n\n# **Pagination**\n\n- Pagination refers to the technique of dividing large result sets into smaller, more manageable subsets or pages. In the context of MongoDB, pagination is commonly used when querying large collections to limit the number of results returned at once and improve performance. MongoDB provides various mechanisms to implement pagination, such as the skip() and limit() methods, which allow you to specify the number of documents to skip and the maximum number of documents to return in a query result. Pagination helps optimize the retrieval of data and provides a better user experience when working with large datasets.",
  "creationDate": {
    "$date": "2023-06-30T05:00:00.000Z"
  },
  "__v": 0
},
{
  "_id": {
    "$oid": "649ef1f30f9bd4176dfe5604"
  },
  "title": "React",
  "description": "# **REACT**\n\n- React is a popular JavaScript library for building user interfaces. It allows developers to create reusable UI components and efficiently update and render them in response to changes in data. React uses a virtual DOM (Document Object Model) to optimize performance by minimizing direct manipulation of the actual DOM. It follows a component-based architecture, making it easy to build complex UIs by composing smaller, reusable components.\n\n# **create-react-app**\n\n- create-react-app is a command-line tool that provides a convenient way to set up a new React project with a predefined folder structure and build configuration. It automates the setup process, including the installation of necessary dependencies, so developers can quickly start building React applications without worrying about the initial project setup.\n\n# **What are React Components?**\n\n- React components are the building blocks of a React application. They encapsulate reusable UI elements and their behavior, making it easy to manage and update the UI. Components can be either class-based components or functional components (introduced in React 16.8), which are simpler and more lightweight. React components receive data as properties (props) and can maintain internal state, allowing them to dynamically render and respond to changes in data.\n\n# **Functional Components**\n\n- Functional components, also known as stateless components or functional stateless components, are a simpler and more concise way to define React components. They are functions that receive props as parameters and return JSX (JavaScript XML) to describe the component's UI. Functional components have become the preferred way of writing components in React due to their simplicity, reusability, and improved performance.\n\n# **React Hooks**\n\nReact Hooks are functions introduced in React 16.8 that allow developers to use state and other React features in functional components without the need for class components. Hooks provide a way to manage component state, perform side effects, access context, and more. Some commonly used React Hooks are:\n\n**useState:** Enables functional components to manage state by providing a state variable and a function to update it.\n**useEffect:** Allows performing side effects (e.g., fetching data, subscribing to events) in functional components. It runs after every render or when specific dependencies change.\n**useContext:** Enables accessing and using context within functional components, allowing components to consume shared data without prop drilling.\n**useReducer:** Provides a way to manage complex state logic by using a reducer function similar to how it's done in Redux.\n\n# **Create Your Own Custom Hook(s)**\n\n- Custom Hooks in React allow developers to encapsulate and reuse logic across components. By extracting reusable logic into custom hooks, you can abstract away complex functionality and create more modular and reusable code. Custom hooks can be used to manage state, handle side effects, perform data fetching, or any other logic that needs to be shared across multiple components.\n\n# **react-router**\n\n- react-router is a popular library for handling routing in React applications. It provides a declarative way to define routes and their corresponding components, allowing for navigation between different views or pages in a React application. react-router supports various types of routing, including nested routes, parameterized routes, and query parameters, making it easy to build dynamic and responsive single-page applications.\n\n# **axios**\n\n- axios is a widely used JavaScript library for making HTTP requests in browsers and Node.js. It provides a simple and intuitive API for sending asynchronous HTTP requests and handling responses. axios supports features like request cancellation, interceptors for request and response transformations, automatic JSON parsing, and more. It is commonly used in React applications to fetch data from APIs and handle AJAX requests.\n\n# **Rendering Markdown with react-markdown**\n\n- react-markdown is a library that allows you to render Markdown content as React components. It converts Markdown syntax into corresponding HTML elements and provides configurable options for customizing the rendering process. With react-markdown, you can easily display and render Markdown content within your React components, making it convenient for creating documentation, blog posts, or any other text-based content that supports Markdown formatting.",
  "creationDate": {
    "$date": "2023-06-30T05:00:00.000Z"
  },
  "__v": 0
}]